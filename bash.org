#+title: Bash
#+author: nsaspy


* Bash Config
This is a literate configuration of my .bashrc
** Setup
Source any global definitions
#+begin_src shell :tangle .bashrc
if [ -f /etc/bashrc ]; then
	. /etc/bashrc
fi
#+end_src

Setup my path
#+begin_src shell :tangle .bashrc
if ! [[ "$PATH" =~ "$HOME/.local/bin:$HOME/bin:" ]]
then
    PATH="$HOME/.local/bin:$HOME/bin:$PATH"
fi
export PATH

#+end_src

Load any extra configuration.
#+begin_src shell :tangle .bashrc
if [ ! -d ~/.bashrc.d ]; then
	for rc in ~/.bashrc.d/*; do
		if [ -f "$rc" ]; then
			. "$rc"
		fi
	done
fi

#+end_src

Setting up colors
#+begin_src shell :tangle .bashrc
export TERM="xterm-256color"                      # getting proper colors
#+end_src

*** History File
Append to the history, dont overwrite.
#+begin_src shell :tangle .bashrc
shopt -s histappend
#+end_src

Save multi line commands as a single line
#+begin_src shell :tangle .bashrc
shopt -s cmdhist # save multi-line commands in history as single line
#+end_src

I Like having a large bashrc history, sometimes theres a command I really want but will get buried under the others.
#+begin_src shell :tangle .bashrc
unset HISTFILESIZE
unset HISTSIZE
HISTCONTROL="ignoreboth"
#+end_src


Set the format of the time.
#+begin_src shell :tangle .bashrc
HISTTIMEFORMAT="[%Y-%m-%d %H:%M:%S] "
#+end_src
Ignore  cd, ls, fg, bg
#+begin_src shell :tangle .bashrc
export HISTIGNORE=fg:bg:ls:cd
#+end_src

*** SHOPT
Common settings.[fn:3]
#+begin_src shell
shopt -s cdspell # autocorrects cd misspellings
shopt -s dotglob
shopt -s checkwinsize # checks term size when bash regains control

#+end_src

*** Bootstrap
This stuff will be ran on first start

To determin what system it is, i use a file this file holds a name which is used by emacs and other things to apply settings for it.
#+begin_src shell :tangle .bashrc
function init_platform () {
# create the .platform file i use
if [ ! -f "$HOME/.platform" ]; then
    echo "no .platform file please enter platform name"
    read platform
    echo $platform > $HOME/.platform
fi
}
init_platform
#+end_src

I have certain stuff that needs to know my ip, like wtr and i prefer not doxxing myself in the git source.
#+begin_src shell :tangle .bashrc
alias get-ip="curl -s -q ifconfig.me"
get-ip > "$HOME/.local/share/ip"
#+end_src
** Bashrc

*** Functions

Extract compresses files[fn:3]
#+begin_src shell :tangle .bashrc
ex ()
{
  if [ -f "$1" ] ; then
    case $1 in
      *.tar.bz2)   tar xjf $1   ;;
      *.tar.gz)    tar xzf $1   ;;
      *.bz2)       bunzip2 $1   ;;
      *.rar)       unrar x $1   ;;
      *.gz)        gunzip $1    ;;
      *.tar)       tar xf $1    ;;
      *.tbz2)      tar xjf $1   ;;
      *.tgz)       tar xzf $1   ;;
      *.zip)       unzip $1     ;;
      *.Z)         uncompress $1;;
      *.7z)        7z x $1      ;;
      *.deb)       ar x $1      ;;
      *.tar.xz)    tar xf $1    ;;
      *.tar.zst)   unzstd $1    ;;
      *)           echo "'$1' cannot be extracted via ex()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

#+end_src

*** Emacs

Set emacs as my editor.[fn:3]
#+begin_src shell :tangle .bashrc
export ALTERNATE_EDITOR=""                        # setting for emacsclient
export EDITOR="emacsclient -t -a ''"              # $EDITOR use Emacs in terminal
export VISUAL="emacsclient -c -a emacs"           # $VISUAL use Emacs in GUI mode
#+end_src

Reinstall Doom emacs
*warning this will remove your emacs install!
#+begin_src shell :tangle .bashrc
function install-doom () {
 if [ -d ~/.emacs.d ]; then
 	echo "Are you sure you want to delete ~/.emacs.d/ directory and install doom emacs? (y/n)"
    read -p "$* [y/n]: " yn
    case $yn in
        [Yy]*) rm -rvf ~/.emacs.d &&  git clone --depth 1 https://github.com/doomemacs/doomemacs.git ~/.emacs.d/ &&  ~/.emacs.d/bin/doom install;;
        [Nn]*) echo "Aborted";;
    esac
 fi
}
#+end_src

Only open new files in a new frame, otherwise open other frame.[fn:2]
#+begin_src shell :tangle .bashrc
function emacs-clean () {
if [ $# -eq 0 ]; then
    emacsclient -c -n
    exit
fi

emacsclient -e "(frames-on-display-list \"$DISPLAY\")" &>/dev/null

if [ $? -eq 0 ]; then
    emacsclient -n "$*"
else
    emacsclient -c -n "$*"
fi
}
#+end_src
*** Nixos
**** Update configuration
This will copy the config, which sort of serves as a Backup I guess.
It will rebuild your config

#+begin_src shell :tangle .bashrc
function evolve () {
read -p "Do you want to rebuild the config? (yes/no) " yn

case $yn in
    yes ) echo ok, we will proceed;;
    no ) echo exiting...;
         exit;;
    * ) echo invalid response;
        exit 1;;
esac
sudo cp -rv $HOME/nixos/* /etc/nixos/
sudo sed  -i "s|<config>|$1/$1.nix|" /etc/nixos/configuration.nix
if [ "$2" = "" ];then
    sudo nixos-rebuild switch
else
nixos-rebuild "$@"
fi
echo done
}
#+end_src
**** Setup nix-env
For some reason on non nixos system this is needed

#+begin_src shell :tangle .bashrc
if [ ! -f "$HOME/.nix-profile/etc/profile.d/nix.sh" ]; then
    source ~/.nix-profile/etc/profile.d/nix.sh
    export NIX_PATH=$HOME/.nix-defexpr/channels:/nix/var/nix/profiles/per-user/root/channels${NIX_PATH:+:$NIX_PATH}
fi
#+end_src

*** Nim
init a nimble project then create a git repo and cd to it
#+begin_src shell :tangle .bashrc
function nim-init () {
 # Init a nim project and start a git repo
 nimble init $1
 git init "$PWD/$1"
}
#+end_src
*** Misc
Misc related functions i found or made
**** Get the top ten used commands [fn:1]
So much cd and ls
#+begin_src shell :tangle .bashrc
function cmdtop () {
    history | awk '{CMD[$2]++;count++;}END { for (a in CMD)print CMD[a] " " CMD[a]/count*100 "% " a;}' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl |  head -n10
}
#+end_src
** Paths
Export nimble path for nim.
#+begin_src shell :tangle .bashrc
export PATH=$PATH:$HOME/.nimble/bin
#+end_src

Export rust cargo path (nasty wax wound lol)
#+begin_src shell :tangle .bashrc
export PATH=$PATH:$HOME/.cargo/bin
#+end_src

Setup my local bin
#+begin_src shell :tangle .bashrc
export PATH=$PATH:$HOME/.bin/
#+end_src
** Aliases
Bash aliases allow you to use a short "alias" for a long command

Expand Aliases
#+begin_src shell :tangle .bashrc
shopt -s expand_aliases # expand aliases
#+end_src

*** Emacs
Run emacs in debug mode
#+begin_src shell :tangle .bashrc
alias debug-emacs="emacs --debug-init"
#+end_src

Open emacs
#+begin_src shell :tangle .bashrc
alias em="emacs -nw"
alias emacs="emacsclient -c -a 'emacs'"
#+end_src
*** Nix
Link home-manager/nix-env to the xgd dirs, without it non nixos systems apps will not be in start bars
#+begin_src shell :tangle .bashrc
alias nix-xdg-link="ln -s ~/.nix-profile/share/applications/ ~/.local/share/applications/nix"
#+end_src
*** Nim
Generate documentation from the project root.
#+begin_src shell :tangle .bashrc
alias nim-doc="nim doc --project --index:on --outdir=docs"
#+end_src

*** GRC
this is the shell aliases to use GRC.
#+begin_src shell :tangle .bashrc
# aliases for grc(1)

# this will execute only if there is a line with
# GRC_ALIASES=true
# in /etc/default/grc or you export GRC_ALIASES=true prior to sourcing this

[ -f /etc/default/grc ] && . /etc/default/grc


GRC="$(which grc)"
if tty -s && [ -n "$TERM" ] && [ "$TERM" != dumb ] && [ -n "$GRC" ]; then
    alias colourify="$GRC -es"
    alias blkid='colourify blkid'
    alias configure='colourify ./configure'
    alias df='colourify df'
    alias diff='colourify diff'
    alias docker='colourify docker'
    alias docker-compose='colourify docker-compose'
    alias docker-machine='colourify docker-machine'
    alias du='colourify du'
#    alias env='colourify env'
    alias free='colourify free'
    alias fdisk='colourify fdisk'
    alias findmnt='colourify findmnt'
    alias make='colourify make'
    alias gcc='colourify gcc'
    alias g++='colourify g++'
    alias id='colourify id'
    alias ip='colourify ip'
    alias iptables='colourify iptables'
    alias as='colourify as'
    alias gas='colourify gas'
    alias journalctl='colourify journalctl'
    alias kubectl='colourify kubectl'
    alias ld='colourify ld'
    #alias ls='colourify ls'
    alias lsof='colourify lsof'
    alias lsblk='colourify lsblk'
    alias lspci='colourify lspci'
    alias netstat='colourify netstat'
    alias ping='colourify ping'
    alias ss='colourify ss'
    alias traceroute='colourify traceroute'
    alias traceroute6='colourify traceroute6'
    alias head='colourify head'
    alias tail='colourify tail'
    alias dig='colourify dig'
    alias mount='colourify mount'
    alias ps='colourify ps'
    alias mtr='colourify mtr'
    alias semanage='colourify semanage'
    alias getsebool='colourify getsebool'
    alias ifconfig='colourify ifconfig'
    alias sockstat='colourify sockstat'
fi

#+end_src
*** Misc
get the weather
I use [[https://wttr.in]] for my weather
#+begin_src shell :tangle .bashrc
alias wttr="curl wttr.in"
#+end_src

Run a couchdb docker container

#+begin_src shell :tangle .bashrc
alias couchdb="mkdir -p $PWD/.database && sudo chown 1001:1001 $PWD/.database && sudo docker run -d  -e COUCHDB_USER=admin -e COUCHDB_PASSWORD=password  -v $PWD/.database:/opt/couchdb/data  -p 0.0.0.0:5984:5984 ibmcom/couchdb3" && echo $PWD/.database >> $HOME/.config/couchdb-databases
#+end_src

Send a notification whenever a command is done.
It defaults to using dunstify.
#+begin_src shell :tangle .bashrc
alert_cmd=$(which "dunstify" || which "notify-send")
alias alert='$alert_cmd --urgency=medium -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
#+end_src

paste to termbin

#+begin_src shell :tangle .bashrc
alias tb="nc termbin.com 9999 >> .bashrc"
#+end_src

Paste to ix.io
#+begin_src shell :tangle .bashrc
alias paste="curl -F 'f:1=<-' ix.io"
alias ix.io="curl -F 'f:1=<-' ix.io"
#+end_src

Go to my hackmode directory.
#+begin_src shell :tangle .bashrc
alias hackmode="cd $HOME/Documents/hackmode"
#+end_src

** Shell Hooks
*** Direnv
#+begin_src shell :tangle .bashrc
eval "$(direnv hook bash)"
#+end_src
*** Starship
#+begin_src shell :tangle .bashrc
eval "$(starship init bash)"
#+end_src

* Footnotes
[fn:3] https://gitlab.com/dwt1/dotfiles/-/blob/master/.bashrc?ref_type=heads

[fn:2] https://taingram.org/blog/emacs-client.html
[fn:1] https://github.com/labbots/bash-oneliners#terminal
